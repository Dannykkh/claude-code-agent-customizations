---
name: reducing-entropy
description: 코드베이스 최소화 철학. 새 파일/기능 추가 전 검토 시 적용.
auto_apply: false
manual_trigger: true
references:
  - skills/reducing-entropy/SKILL.md
---

# Reducing Entropy (Manual Guidelines)

더 많은 코드는 더 많은 코드를 낳습니다. 엔트로피는 누적됩니다.

## Core Question

> **"작업 후 코드베이스가 어떻게 보이는가?"**

## Three Questions (Before Any Change)

### 1. 이 문제를 해결하는 가장 작은 코드베이스는?
- 14개 함수 대신 2개로 가능한가?
- 0개 함수로 가능한가? (기능 삭제?)
- 이걸 하면 뭘 삭제할 수 있는가?

### 2. 제안된 변경이 총 코드를 줄이는가?
변경 전후 줄 수 비교. 후 > 전이면 거부.

- "더 잘 정리됨" + 더 많은 코드 = 더 많은 엔트로피
- "더 유연함" + 더 많은 코드 = 더 많은 엔트로피
- "관심사 분리" + 더 많은 코드 = 더 많은 엔트로피

### 3. 무엇을 삭제할 수 있는가?
모든 변경은 삭제 기회:

- 이것이 무엇을 구식으로 만드는가?
- 교체 대상 때문에만 필요했던 것은?
- 최대한 제거할 수 있는 것은?

## Red Flags

|경고|문제|
|---|---|
|"기존 것 유지"|현상 유지 편향. 총 코드가 중요.|
|"유연성 추가"|무엇을 위한 유연성? YAGNI.|
|"관심사 분리"|더 많은 파일 = 더 많은 코드|
|"타입 안전성"|몇 줄의 가치? 런타임 체크가 더 적을 수도.|
|"이해하기 쉬움"|14개가 2개보다 쉽지 않음.|

## When NOT to Apply

- 코드베이스가 이미 최소한
- 강한 컨벤션의 프레임워크 (싸우지 말 것)
- 규제/컴플라이언스 요구사항

## Measurement

```
성공 = 최종 코드 양, 노력이 아님

50줄 작성 + 200줄 삭제 = 순이익
14개 함수 유지 + 2개 작성 회피 = 순손실
```

**삭제 편향. 최종 상태 측정.**
